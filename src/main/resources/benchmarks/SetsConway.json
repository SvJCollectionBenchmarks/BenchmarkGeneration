{
  "generateMode": "CollectionPerMethod",
  "imports": {
    "java": [
      "import java.util.*;",
      "import org.openjdk.jmh.annotations.*;",
      "import org.openjdk.jmh.infra.Blackhole;"
    ],
    "scala": [
      "import java.util",
      "import scala.collection.immutable",
      "import scala.collection.mutable",
      "import org.openjdk.jmh.annotations._",
      "import org.openjdk.jmh.infra.Blackhole",
      "import java.util.Objects",
      "import scala.collection.mutable.ArrayBuffer"
    ]
  },
  "outerProcessed": {
    "java": [
      "static class Cell {",
      "\tprivate final int row, column;",
      "\tprivate final boolean isAlive;",
      "\tprivate Cell(int row, int column, boolean isAlive) {",
      "\t\tthis.row = row;",
      "\t\tthis.column = column;",
      "\t\tthis.isAlive = isAlive;",
      "\t}",
      "\tpublic static Cell livingCell(int row, int column) {",
      "\t\treturn new Cell(row, column, true);",
      "\t}",
      "\tpublic static Cell deadCell(int row, int column) {",
      "\t\treturn new Cell(row, column, false);",
      "\t}",
      "\tpublic int row() {",
      "\t\treturn row;",
      "\t}",
      "\tpublic int column() {",
      "\t\treturn column;",
      "\t}",
      "\tpublic boolean isAlive() {",
      "\t\treturn isAlive;",
      "\t}",
      "\t@Override",
      "\tpublic boolean equals(Object o) {",
      "\t\tif (this == o) return true;",
      "\t\tif (o == null || getClass() != o.getClass()) return false;",
      "\t\tCell cell = (Cell) o;",
      "\t\treturn row == cell.row && column == cell.column && isAlive == cell.isAlive;",
      "\t}",
      "\t@Override",
      "\tpublic int hashCode() {",
      "\t\treturn Objects.hash(row, column, isAlive);",
      "\t}",
      "}",
      "private static final List<Cell> startingPoint = Arrays.asList(",
      "\tCell.livingCell(0,0), Cell.livingCell(1,0), Cell.livingCell(2,0),",
      "\tCell.livingCell(3,1),",
      "\tCell.livingCell(1,2), Cell.livingCell(2,2),",
      "\tCell.livingCell(3,3),",
      "\tCell.livingCell(0,4), Cell.livingCell(1,4), Cell.livingCell(2,4)",
      ");",
      "private static void addLivingCell(Set<Cell> collection, int row, int column) {",
      "\tcollection.remove(Cell.deadCell(row, column));",
      "\tcollection.add(Cell.livingCell(row, column));",
      "\tfor (int i = -1; i < 2; i++) {",
      "\t\tfor (int j = -1; j < 2; j++) {",
      "\t\t\tif (!(i == 0 && j == 0) && !collection.contains(Cell.livingCell(row+i, column+j)))",
      "\t\t\t\tcollection.add(Cell.deadCell(row+i, column+j));",
      "\t\t}",
      "\t}",
      "}",
      "private static void removeLivingCell(Set<Cell> collection, int row, int column) {",
      "\tcollection.remove(Cell.livingCell(row, column));",
      "\tif (neighboursCount(collection, row, column) != 0)",
      "\t\tcollection.add(Cell.deadCell(row, column));",
      "\tfor (int i = -1; i < 2; i++) {",
      "\t\tfor (int j = -1; j < 2; j++) {",
      "\t\t\tif (!(i == 0 && j == 0) && neighboursCount(collection, row+i, column+j) == 0)",
      "\t\t\t\tcollection.remove(Cell.deadCell(row+i, column+j));",
      "\t\t}",
      "\t}",
      "}",
      "private static int neighboursCount(Set<Cell> collection, int row, int column) {",
      "\tint neighbours = 0;",
      "\tfor (int i = -1; i < 2; i++) {",
      "\t\tfor (int j = -1; j < 2; j++) {",
      "\t\t\tif (!(i == 0 && j == 0) && collection.contains(Cell.livingCell(row+i, column+j)))",
      "\t\t\t\tneighbours += 1;",
      "\t\t}",
      "\t}",
      "\treturn neighbours;",
      "}"
    ],
    "scala": [
      "object Cell {",
      "\tdef livingCell(row: Int, column: Int) = new Cell(row, column, true)",
      "\tdef deadCell(row: Int, column: Int) = new Cell(row, column, false)",
      "}",
      "class Cell private(val row: Int, val column: Int, val isAlive: Boolean) {",
      "\toverride def equals(o: Any): Boolean = {",
      "\t  if (o == null || (getClass ne o.getClass)) return false",
      "\t  val cell = o.asInstanceOf[Cell]",
      "\t  row == cell.row && column == cell.column && isAlive == cell.isAlive",
      "\t}",
      "\toverride def hashCode: Int = Objects.hash(row, column, isAlive)",
      "}",
      "private val startingPoint = ArrayBuffer(",
      "\tCell.livingCell(0, 0), Cell.livingCell(1, 0), Cell.livingCell(2, 0),",
      "\tCell.livingCell(3, 1),",
      "\tCell.livingCell(1, 2), Cell.livingCell(2, 2),",
      "\tCell.livingCell(3, 3),",
      "\tCell.livingCell(0, 4), Cell.livingCell(1, 4), Cell.livingCell(2, 4)",
      ")",
      "private def addLivingCell(collection: mutable.Set[Cell], row: Int, column: Int): Unit = {",
      "\tcollection.remove(Cell.deadCell(row, column))",
      "\tcollection.add(Cell.livingCell(row, column))",
      "\tfor (i <- -1 until 2)",
      "\t  for (j <- -1 until 2)",
      "\t\tif (!(i == 0 && j == 0) && !collection.contains(Cell.livingCell(row + i, column + j)))",
      "\t\t  collection.add(Cell.deadCell(row + i, column + j))",
      "}",
      "private def removeLivingCell(collection: mutable.Set[Cell], row: Int, column: Int): Unit = {",
      "\tcollection.remove(Cell.livingCell(row, column))",
      "\tif (neighboursCount(collection, row, column) != 0) collection.add(Cell.deadCell(row, column))",
      "\tfor (i <- -1 until 2)",
      "\t  for (j <- -1 until 2)",
      "\t\tif (!(i == 0 && j == 0) && neighboursCount(collection, row + i, column + j) == 0)",
      "\t\t  collection.remove(Cell.deadCell(row + i, column + j))",
      "}",
      "private def neighboursCount(collection: mutable.Set[Cell], row: Int, column: Int): Int = {",
      "\tvar neighbours = 0",
      "\tfor (i <- -1 until 2)",
      "\t  for (j <- -1 until 2)",
      "\t\tif (!(i == 0 && j == 0) && collection.contains(Cell.livingCell(row + i, column + j)))",
      "\t\t  neighbours += 1",
      "\tneighbours",
      "}"
    ]
  },
  "outerUnprocessed": {
    "java": [""],
    "scala": [""]
  },
  "groups": [
    "GeneralSets"
  ],
  "variables": {
    "profiled": {
      "java": {
        "java": {
          "iteratorImport": "java.util.Iterator"
        },
        "scala": {
          "iteratorImport": "scala.collection.Iterator"
        }
      }
    }
  }
}