{
  "generateMode": "CollectionPerMethod",
  "imports": {
    "java": [
      "import java.util.*;",
      "import org.openjdk.jmh.annotations.*;",
      "import org.openjdk.jmh.infra.Blackhole;"
    ],
    "scala": [
      "import java.util",
      "import scala.collection.immutable",
      "import scala.collection.mutable",
      "import org.openjdk.jmh.annotations._",
      "import org.openjdk.jmh.infra.Blackhole"
    ]
  },
  "outerProcessed": {
    "java": [""],
    "scala": [""]
  },
  "outerUnprocessed": {
    "java": [
      "static class Cell {",
      "  private final int row, column;",
      "  private final boolean isAlive;",
      "  private Cell(int row, int column, boolean isAlive) {",
      "    this.row = row;",
      "    this.column = column;",
      "    this.isAlive = isAlive;",
      "  }",
      "  public static Cell livingCell(int row, int column) {",
      "    return new Cell(row, column, true);",
      "  }",
      "  public static Cell deadCell(int row, int column) {",
      "    return new Cell(row, column, false);",
      "  }",
      "  public int row() {",
      "    return row;",
      "  }",
      "  public int column() {",
      "    return column;",
      "  }",
      "  public boolean isAlive() {",
      "    return isAlive;",
      "  }",
      "  @Override",
      "  public boolean equals(Object o) {",
      "    if (this == o) return true;",
      "    if (o == null || getClass() != o.getClass()) return false;",
      "    Cell cell = (Cell) o;",
      "    return row == cell.row && column == cell.column && isAlive == cell.isAlive;",
      "  }",
      "  @Override",
      "  public int hashCode() {",
      "    return Objects.hash(row, column, isAlive);",
      "  }",
      "}",
      "private static final List<Cell> startingPoint = Arrays.asList(",
      "  Cell.livingCell(0,0), Cell.livingCell(1,0), Cell.livingCell(2,0),",
      "  Cell.livingCell(3,1),",
      "  Cell.livingCell(1,2), Cell.livingCell(2,2),",
      "  Cell.livingCell(3,3),",
      "  Cell.livingCell(0,4), Cell.livingCell(1,4), Cell.livingCell(2,4)",
      ");",
      "private static void addLivingCell(Set<Cell> collection, int row, int column) {",
      "  collection.remove(Cell.deadCell(row, column));",
      "  collection.add(Cell.livingCell(row, column));",
      "  for (int i = -1; i < 2; i++) {",
      "    for (int j = -1; j < 2; j++) {",
      "      if (!(i == 0 && j == 0) && !collection.contains(Cell.livingCell(row+i, column+j)))",
      "        collection.add(Cell.deadCell(row+i, column+j));",
      "    }",
      "  }",
      "}",
      "private static void removeLivingCell(Set<Cell> collection, int row, int column) {",
      "  collection.remove(Cell.livingCell(row, column));",
      "  if (neighbours(collection, row, column) != 0)",
      "    collection.add(Cell.deadCell(row, column));",
      "  for (int i = -1; i < 2; i++) {",
      "    for (int j = -1; j < 2; j++) {",
      "      if (!(i == 0 && j == 0) && neighbours(collection, row+i, column+j) == 0)",
      "        collection.remove(Cell.deadCell(row+i, column+j));",
      "    }",
      "  }",
      "}",
      "private static int neighbours(Set<Cell> collection, int row, int column) {",
      "  int neighbours = 0;",
      "  for (int i = -1; i < 2; i++) {",
      "    for (int j = -1; j < 2; j++) {",
      "      if (!(i == 0 && j == 0) && collection.contains(Cell.livingCell(row+i, column+j)))",
      "        neighbours += 1;",
      "    }",
      "  }",
      "  return neighbours;",
      "}"
    ],
    "scala": [
      "object Cell {",
      "  def livingCell(row: Int, column: Int) = new Weird.Cell(row, column, true)",
      "  def deadCell(row: Int, column: Int) = new Weird.Cell(row, column, false)",
      "}",
      "class Cell private(val row: Int, val column: Int, val isAlive: Boolean) {",
      "  override def equals(o: Any): Boolean = {",
      "    if (this == o) return true",
      "    if (o == null || (getClass ne o.getClass)) return false",
      "    val cell = o.asInstanceOf[Weird.Cell]",
      "    row == cell.row && column == cell.column && isAlive == cell.isAlive",
      "  }",
      "  override def hashCode: Int = Objects.hash(row, column, isAlive)",
      "}",
      "private val startingPoint = util.Arrays.asList(",
      "  Cell.livingCell(0, 0), Cell.livingCell(1, 0), Cell.livingCell(2, 0),",
      "  Cell.livingCell(3, 1),",
      "  Cell.livingCell(1, 2), Cell.livingCell(2, 2),",
      "  Cell.livingCell(3, 3),",
      "  Cell.livingCell(0, 4), Cell.livingCell(1, 4), Cell.livingCell(2, 4)",
      ")",
      "private def addLivingCell(collection: mutable.Set[Weird.Cell], row: Int, column: Int): Unit = {",
      "  collection.remove(Cell.deadCell(row, column))",
      "  collection.add(Cell.livingCell(row, column))",
      "  for (i <- -1 until 2) ",
      "    for (j <- -1 until 2)",
      "      if (!(i == 0 && j == 0) && !collection.contains(Cell.livingCell(row + i, column + j)))",
      "        collection.add(Cell.deadCell(row + i, column + j))",
      "}",
      "private def removeLivingCell(collection: mutable.Set[Weird.Cell], row: Int, column: Int): Unit = {",
      "  collection.remove(Cell.livingCell(row, column))",
      "  if (neighbours(collection, row, column) != 0) collection.add(Cell.deadCell(row, column))",
      "    for (i <- -1 until 2)",
      "      for (j <- -1 until 2)",
      "        if (!(i == 0 && j == 0) && neighbours(collection, row + i, column + j) == 0)",
      "          collection.remove(Cell.deadCell(row + i, column + j))",
      "}",
      "private def neighbours(collection: mutable.Set[Weird.Cell], row: Int, column: Int) = {",
      "  var neighbours = 0",
      "  for (i <- -1 until 2)",
      "    for (j <- -1 until 2)",
      "      if (!(i == 0 && j == 0) && collection.contains(Cell.livingCell(row + i, column + j)))",
      "        neighbours += 1",
      "  neighbours",
      "}"
    ]
  },
  "groups": [
    "GeneralSets"
  ],
  "variables": {
    "profiled": {
      "java": {
        "java": {
          "iteratorImport": "java.util.Iterator"
        },
        "scala": {
          "iteratorImport": "scala.collection.Iterator"
        }
      }
    }
  }
}